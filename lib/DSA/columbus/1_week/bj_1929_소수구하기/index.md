## 1. 문제설명

---

→ 문제 요약(시간이 지나고 봐도 빠르게 파악이 가능하게 간단하게 정리할 것)

주어진  두 수 사이의 소수구하기

## 2. 접근 방식

---

→ 생각 과정 자세하게 적기

### 1. 시간복잡도(있다면 적을 것)

>(1 ≤ M ≤ N ≤ 1,000,000) 
>

### 2. 문제 조건 분석 과정
소수 구하기 -> 1과 자기 자신만 나누어 떨어지는 수 중에 1보다 큰 수를 말한다. 2가 가장 작은 소수가 된다.

### 3. 최종 선택한 자료구조/알고리즘 혹은 풀이 방법

#### 소수를 판별하는 가장 직관적인 방법

- 현재수 를 2부터 나누어 보는 것 
- 현재수/2, 현재수/3 ... 현재수 / sqrt 현재수 까지 계산해서 나누어 떨어지는 경우가 한 번이라도 있으면 그 수는 소수가 아님 (합성수)
- 수가 한 개만 주어지면 O(sqrt(n)) 만큼의 복잡도 
- 문제에서는 n부터 m까지의 소수구하기 
- n+1 -> O(sqrt(n)) *  


에라토스테네스 체 구현. 

- 2부터 시작해 순회하면서 현재 숫자의 배수들을 리스트에서 지운다. 
- 3부터 시작해 순회하면서 현재 숫자의 배수들을 리스트에서 지운다.
- ...


*위 3가지는 가이드라인일 뿐, 본인이 생각한 과정을 적으면 됨.

## 3. 틀린 이유 설명

- 시간초과나는 코드임. 직관적인 방법을 사용함.
- 현재수(i) 를 현재수 다음 수부터 나누는데, 이 로직도 지금 잘못되엇음. 
- i번째 수가 소수가 아니라면, 그 수의 모든 배수들을 찾아내 지워야 한다.
```python

n,m = map(int, input().split())

arr = [ i for i in range(n, m+1)]  #n 부터 m까지의 리스트 
isPrime = [False for i in range(0, len(arr))] #arr 에 상응하는 isPrime 리스트  
for i in range(0, len(arr)): # n~m길이 만큼의 순회
    if ( isPrime[i] ): # i번째가 소수라면 
            continue # 이미 소수인걸 알았다면 넘기기 
    else: #아니라면
        for j in range(i+1, len(arr)):  #다음숫자부터 끝까지 순회 
            if not isPrime[j] and arr[j]%arr[i] ==0: # 현재 숫자가 소수가 아니고, 현재숫자에서 고정된 수 나누어서 떨어지면 
                isPrime[j] = True #소수이다.

for i in range(0, len(isPrime)):
    if isPrime[i]:
        print(arr[i])

```



→ 어디서 막혔는지 왜 막혔는지 자세하게 기술

## 4. 올바른 접근 방식 및 해결 방식

제곱근까지만 계산함으로써 최적화 할 수 있다.

---

1. 어떻게 해결했는지
2. 올바른 접근 방식은 뭔지

- 2부터 √m까지의 숫자에 대해 반복합니다.
- 현재 숫자 i가 소수라면, i의 배수들을 모두 소수가 아닌 것 으로 표시 합니다.

- `is_prime`의 초깃값이 모두 True 이기 때문에 ,
- is_prime[i]이 true 이면, i의 배수들을 찾아 False로 변경해 소수에서 제외시켜 줘야 한다. 
- i의 배수를 순회할 때, 초기 시작을 `i*i` 으로 두는 이유는 `i*i` 이전 값들은 이미 i이전의 배수를 구할 때 소거가 되었던 것들이다. 
- 예를 들어 현재 i =3 , 3*3=9부터 초깃값 시작 
- i = 2일 때: 4, 6, 8을 제거합니다. 
- i = 3일 때: 이미 8까지 제거 되어 있음, 9부터 시작하여 9, 12, 15...를 제거합니다.
- 의심스러운 부분 : 3,4,5,6,7,8 소수 판별 보장성이 되는지?
- i= 2일 때, 2,4,6,8 은 이미 소수 아님, 나머지 3 5 7 은 소수니 그대로 둔다. 


## 5. 최종 코드


```python

n,m = map(int, input().split())

is_prime = [True] * (m + 1)  #0부터 m까지 프라임인지 구함(0부터 m까지의 모든 수를 일단 소수로 가정 (True로 표시))

is_prime[0] = is_prime[1] = False # 0이랑, 1은 소수가 아님 


for i in range(2, int(m**0.5) + 1): #2부터 m의 제곱근까지 반복
    if is_prime[i]: # i가 소수라면 
        # i의 배수들을 모두 소수가 아닌 것으로 표시
        for j in range(i*i, m+1, i):  #초기 시작은 i*i , i배수 만큼 증가, 
            is_prime[j]=False

for i in range(n, m+1):
    if( is_prime[i]):
        print(i)


```